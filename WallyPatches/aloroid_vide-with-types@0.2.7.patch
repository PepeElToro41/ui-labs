diff --git a/vide-with-types/src/bind.luau b/vide-with-types/src/bind.luau
index 36de135..7e5321f 100644
--- a/vide-with-types/src/bind.luau
+++ b/vide-with-types/src/bind.luau
@@ -54,7 +54,9 @@ local function update_children_effect(p: ChildrenBinding)
             for _, child in next, child do
                 process_child(child)
             end
-        else
+        elseif type(child) == "function" then
+            process_child(child())
+        elseif child then
             if new_child_set[child] then return end -- stops redundant reparenting
 
             new_child_set[child] = true -- record child set from this update
diff --git a/vide-with-types/src/context.luau b/vide-with-types/src/context.luau
new file mode 100644
index 0000000..8615630
--- /dev/null
+++ b/vide-with-types/src/context.luau
@@ -0,0 +1,72 @@
+local graph = require(script.Parent.graph)
+local create_node = graph.create_node
+local get_scope = graph.get_scope
+local push_scope = graph.push_scope
+local pop_scope = graph.pop_scope
+
+type Node = graph.Node<any>
+
+export type Context<T> = {
+    provide: <V>(value: T, callback: (() -> V)) -> V,
+    consume: () -> T,
+}
+
+type InternalContext<T> = Context<T> & {
+    default: T,
+    providers: { [Node]: T }
+}
+
+
+local function provide_context<T>(context: InternalContext<T>, value: T)
+    local scope = get_scope()
+    if not scope then error("contexts must be used inside a scope") end
+
+    local provided_scope = create_node(scope, false, false)
+    context.providers[provided_scope] = value
+    return provided_scope
+end
+
+local function consume_context<T>(context: InternalContext<T>): T
+    local owner = get_scope()
+    if not owner then error("contexts must be used inside a scope") end
+
+    while true do
+        local value = context.providers[owner]
+        if value then return value end
+
+        if not owner.owner then break end
+        owner = owner.owner
+    end
+
+    return context.default
+end
+
+local function create_context<T>(default: T?): Context<T>
+    local context = {
+        default = default,
+        providers = {}
+    } :: InternalContext<T>
+
+    context.provide = function<V>(value: T, callback: (() -> V)): V
+        local scope = provide_context(context, value)
+        
+        push_scope(scope)
+        local ok, result = pcall(callback)
+        pop_scope()
+
+        if not ok then error(result, 0) end
+
+        return result
+    end
+
+    context.consume = function()
+        return consume_context(context)
+    end
+
+    return context
+end
+
+
+return table.freeze {
+    create_context = create_context,
+}
\ No newline at end of file
diff --git a/vide-with-types/src/init.luau b/vide-with-types/src/init.luau
index 854a30e..c1bf84a 100644
--- a/vide-with-types/src/init.luau
+++ b/vide-with-types/src/init.luau
@@ -26,7 +26,11 @@ local throw = require(script.throw)
 local flags = require(script.flags)
 local roblox_types = require(script.roblox_types)
 
+local context = require(script.context)
+local scope = require(script.scope)
+
 export type Source<T> = source.Source<T>
+export type Context<T> = context.Context<T>
 -- TYPES HERE
 export type vCanvasGroup = roblox_types.vCanvasGroup
 export type vFrame = roblox_types.vFrame
@@ -120,6 +124,17 @@ local vide = {
     action = action,
     changed = changed,
 
+    -- scope
+    inner_scope = scope.inner_scope,
+    create_scope = scope.create_scope,
+    destroy_scope = scope.destroy_scope,
+    get_scope = scope.get_scope,
+    is_stable = scope.is_stable,
+    get_owner = scope.get_owner,
+   
+    -- contexts
+    create_context = context.create_context,
+
     -- flags
     strict = (nil :: any) :: boolean,
 
diff --git a/vide-with-types/src/roblox_types.luau b/vide-with-types/src/roblox_types.luau
index 7947ee7..45ab77d 100644
--- a/vide-with-types/src/roblox_types.luau
+++ b/vide-with-types/src/roblox_types.luau
@@ -1,9 +1,10 @@
 type p<T> = T?|()->T
 type e<T=()->()> = T?
 type a={priority: number, callback: (Instance) -> ()}
-type c<T> =a|T|Instance|()->{Instance}|Instance
+type c<T> = a | T | Instance | (()->{Instance}) | (() -> Instance?) |Instance
 type Dictionary = {[string]: any}
 type Array = {any}
+
 export type vCanvasGroup = {
 	GroupColor3: p<Color3>,
 	GroupTransparency: p<number>,
diff --git a/vide-with-types/src/scope.luau b/vide-with-types/src/scope.luau
new file mode 100644
index 0000000..f2057ac
--- /dev/null
+++ b/vide-with-types/src/scope.luau
@@ -0,0 +1,68 @@
+local graph = require(script.Parent.graph)
+
+type Node<T = any> = graph.Node<T>
+local get_scope = graph.get_scope
+local create_node = graph.create_node
+local push_scope = graph.push_scope
+local pop_scope = graph.pop_scope
+
+local function run_in_scope(scope: Node, callback: () -> any)
+    push_scope(scope)
+
+    local ok, result = pcall(callback)
+
+    pop_scope()
+
+    if not ok then error(result, 0) end
+end
+
+local function create_scope(owner: Node, callback: (() -> any)?): Node
+	local new_scope = create_node(owner, false, false)
+	
+    if callback then run_in_scope(new_scope, callback) end
+
+	return new_scope
+end
+
+local function inner_scope(callback: (() -> ())?): Node
+    local owner = graph.get_scope()
+    if not owner then error("inner_scope must be called inside a scope") end
+
+    return create_scope(owner, callback)
+end
+ 
+
+local function is_stable(scope: Node?): boolean
+    scope = scope or graph.get_scope()
+
+    if not scope then return false end
+    return not scope.effect
+end
+
+local function destroy_scope(scope: Node)
+    graph.destroy(scope)
+end
+
+local function get_owner(scope: Node?): Node?
+    scope = scope or get_scope()
+    if not scope then return nil end
+
+    local owner = scope.owner :: Node | false
+
+    if owner then
+        return owner :: Node
+    else
+        return nil
+    end
+end
+
+
+return table.freeze {
+    run_in_scope = run_in_scope,
+	create_scope = create_scope,
+    inner_scope = inner_scope,
+	destroy_scope = destroy_scope,
+	get_scope = get_scope,
+    is_stable = is_stable,
+	get_owner = get_owner,
+}
\ No newline at end of file
